/* eslint-disable prefer-named-capture-group */
const DEBUG = false

export enum TokenKind {
	Identifier,
	Newline,
	Function,
	As,
	To,
	Type,
	Let,
	Constant,
	Return,
	If,
	Until,
	Do,
	With,
	Else,
	Loop,
	String,
	Colon,
	Call,
	OpenBracket,
	OpenSquiglyBracket,
	CloseSquiglyBracket,
	OpenSquareBracket,
	CloseSquareBracket,
	Comma,
	CloseBracket,
	Xor,
	Increment,
	Decrement,
	Add,
	Minus,
	Divide,
	Power,
	Times,
	Equals,
	Modulo,
	LogicalAnd,
	LogicalOr,
	LogicalNot,
	NullishCoalesce,
	BitwiseAnd,
	BitwiseOr,
	BitwiseNot,
	Assign,
	OptionalChain,
	LeftShift,
	RightShift,
	Error,
	HexNumber,
	Number,
	OctalNumber,
	BinaryNumber,
	Import,
	Break,
	Continue,
	SignedIntegerType,
	UnsignedIntegerType,
	Float16Type,
	Float32Type,
	Float64Type,
	Float128Type,
	Null,
	Void,
	True,
	False,
	Boolean,
	While,
	DeclareFunction,
	WrappingTimes,
	DeclareModule,
	Module,
	Declare,
	Dot,
	Arrow,
	BiggerThan,
	SmallerThan,
	For,
	Tag,
	Enumeration,
	ThickArrow,
	Private,
	Internal,
	Match,
	When,
	Block,
	Readonly,
	Mutable,
	Abstract,
	Arguments,
	Await,
	Character,
	Class,
	Debugger,
	Default,
	Delete,
	Double,
	Evaluate,
	Export,
	Extends,
	Final,
	Finally,
	Float,
	Goto,
	Implements,
	In,
	Instanceof,
	Integer,
	Interface,
	Long,
	Native,
	New,
	Package,
	Protected,
	Public,
	Short,
	Static,
	Super,
	Switch,
	Synchronized,
	This,
	Throw,
	Throws,
	Transient,
	Try,
	Typeof,
	Typeis,
	// eslint-disable-next-line unicorn/prevent-abbreviations
	Var,
	Volatile,
	Yield,
	External,
	Reference,
	Catch,
	Self,
	CapitalisedSelf,
	Trait,
	Traits,
	Methods,
	Method,
	Unsafe,
	Where,
	Use,
	Structure,
	Become,
	Box,
	Boxed,
	Macro,
	Override,
	Unsized,
	Sizeof,
	Size,
	Virtual,
	Union,
	Dynamic,
	Async,
	Of,
	Define,
	Namespace,
	Comptime,
	From,
	Test,
	Tests,
	Unless,
	Any,
	Unknown,
	Unique,
	Symbol,
	Runtime,
	Opaque
}

export type Token = { kind: TokenKind, data: string | undefined, index: number, line: number, column: number }

const tokenRegexes: { regex: RegExp, tokenKind: TokenKind }[] = [
	{ regex: /^while(?![$\w])/, tokenKind: TokenKind.While },
	{ regex: /^boolean(?![$\w])/, tokenKind: TokenKind.Boolean },
	{ regex: /^false(?![$\w])/, tokenKind: TokenKind.False },
	{ regex: /^true(?![$\w])/, tokenKind: TokenKind.True },
	{ regex: /^void(?![$\w])/, tokenKind: TokenKind.Void },
	{ regex: /^null(?![$\w])/, tokenKind: TokenKind.Null },
	{ regex: /^f16(?![$\w])/, tokenKind: TokenKind.Float16Type },
	{ regex: /^f32(?![$\w])/, tokenKind: TokenKind.Float32Type },
	{ regex: /^f64(?![$\w])/, tokenKind: TokenKind.Float64Type },
	{ regex: /^f128(?![$\w])/, tokenKind: TokenKind.Float128Type },
	{ regex: /^(?:function|fn)(?![$\w])/, tokenKind: TokenKind.Function },
	{ regex: /^as(?![$\w])/, tokenKind: TokenKind.As },
	{ regex: /^to(?![$\w])/, tokenKind: TokenKind.To },
	{ regex: /^type(?![$\w])/, tokenKind: TokenKind.Type },
	{ regex: /^let(?![$\w])/, tokenKind: TokenKind.Let },
	{ regex: /^const(?:ant)?(?![$\w])/, tokenKind: TokenKind.Constant },
	{ regex: /^return(?![$\w])/, tokenKind: TokenKind.Return },
	{ regex: /^if(?![$\w])/, tokenKind: TokenKind.If },
	{ regex: /^until(?![$\w])/, tokenKind: TokenKind.Until },
	{ regex: /^do(?![$\w])/, tokenKind: TokenKind.Do },
	{ regex: /^with(?![$\w])/, tokenKind: TokenKind.With },
	{ regex: /^else(?![$\w])/, tokenKind: TokenKind.Else },
	{ regex: /^loop(?![$\w])/, tokenKind: TokenKind.Loop },
	{ regex: /^import(?![$\w])/, tokenKind: TokenKind.Import },
	{ regex: /^break(?![$\w])/, tokenKind: TokenKind.Break },
	{ regex: /^continue(?![$\w])/, tokenKind: TokenKind.Continue },
	{ regex: /^declare(?![$\w])/, tokenKind: TokenKind.Declare },
	{ regex: /^function(?![$\w])/, tokenKind: TokenKind.Function },
	{ regex: /^mod(?:ule)?(?![$\w])/, tokenKind: TokenKind.Module },
	{ regex: /^for(?![$\w])/, tokenKind: TokenKind.For },
	{ regex: /^tag(?![$\w])/, tokenKind: TokenKind.Tag },
	{ regex: /^enum(?:eration)?(?![$\w])/, tokenKind: TokenKind.Enumeration },
	{ regex: /^priv(?:ate)?(?![$\w])/, tokenKind: TokenKind.Private },
	{ regex: /^internal(?![$\w])/, tokenKind: TokenKind.Internal },
	{ regex: /^match(?![$\w])/, tokenKind: TokenKind.Match },
	{ regex: /^when(?![$\w])/, tokenKind: TokenKind.When },
	{ regex: /^do(?![$\w])/, tokenKind: TokenKind.Do },
	{ regex: /^block(?![$\w])/, tokenKind: TokenKind.Block },
	{ regex: /^readonly(?![$\w])/, tokenKind: TokenKind.Readonly },
	{ regex: /^mut(?:able)?(?![$\w])/, tokenKind: TokenKind.Mutable },
	{ regex: /^abstract(?![$\w])/, tokenKind: TokenKind.Abstract },
	{ regex: /^arguments(?![$\w])/, tokenKind: TokenKind.Arguments },
	{ regex: /^await(?![$\w])/, tokenKind: TokenKind.Await },
	{ regex: /^async(?![$\w])/, tokenKind: TokenKind.Async },
	{ regex: /^char(?:acter)?(?![$\w])/, tokenKind: TokenKind.Character },
	{ regex: /^class(?![$\w])/, tokenKind: TokenKind.Class },
	{ regex: /^debug(?:ger)?(?![$\w])/, tokenKind: TokenKind.Debugger },
	{ regex: /^default(?![$\w])/, tokenKind: TokenKind.Default },
	{ regex: /^delete(?![$\w])/, tokenKind: TokenKind.Delete },
	{ regex: /^double(?![$\w])/, tokenKind: TokenKind.Double },
	{ regex: /^eval(?:uate)?(?![$\w])/, tokenKind: TokenKind.Evaluate },
	{ regex: /^export(?![$\w])/, tokenKind: TokenKind.Export },
	{ regex: /^extends(?![$\w])/, tokenKind: TokenKind.Extends },
	{ regex: /^final(?![$\w])/, tokenKind: TokenKind.Final },
	{ regex: /^finally(?![$\w])/, tokenKind: TokenKind.Finally },
	{ regex: /^float(?![$\w])/, tokenKind: TokenKind.Float },
	{ regex: /^goto(?![$\w])/, tokenKind: TokenKind.Goto },
	{ regex: /^impl(?:ements)?(?![$\w])/, tokenKind: TokenKind.Implements },
	{ regex: /^in(?![$\w])/, tokenKind: TokenKind.In },
	{ regex: /^instanceof(?![$\w])/, tokenKind: TokenKind.Instanceof },
	{ regex: /^int(?:eger)?(?![$\w])/, tokenKind: TokenKind.Integer },
	{ regex: /^interface(?![$\w])/, tokenKind: TokenKind.Interface },
	{ regex: /^long(?![$\w])/, tokenKind: TokenKind.Long },
	{ regex: /^native(?![$\w])/, tokenKind: TokenKind.Native },
	{ regex: /^new(?![$\w])/, tokenKind: TokenKind.New },
	{ regex: /^package(?![$\w])/, tokenKind: TokenKind.Package },
	{ regex: /^protected(?![$\w])/, tokenKind: TokenKind.Protected },
	{ regex: /^pub(?:lic)?(?![$\w])/, tokenKind: TokenKind.Public },
	{ regex: /^short(?![$\w])/, tokenKind: TokenKind.Short },
	{ regex: /^static(?![$\w])/, tokenKind: TokenKind.Static },
	{ regex: /^super(?![$\w])/, tokenKind: TokenKind.Super },
	{ regex: /^switch(?![$\w])/, tokenKind: TokenKind.Switch },
	{ regex: /^syncronized(?![$\w])/, tokenKind: TokenKind.Synchronized },
	{ regex: /^this(?![$\w])/, tokenKind: TokenKind.This },
	{ regex: /^throw(?![$\w])/, tokenKind: TokenKind.Throw },
	{ regex: /^throws(?![$\w])/, tokenKind: TokenKind.Throws },
	{ regex: /^transient(?![$\w])/, tokenKind: TokenKind.Transient },
	{ regex: /^try(?![$\w])/, tokenKind: TokenKind.Try },
	{ regex: /^typeof(?![$\w])/, tokenKind: TokenKind.Typeof },
	{ regex: /^typeis(?![$\w])/, tokenKind: TokenKind.Typeis },
	{ regex: /^var(?![$\w])/, tokenKind: TokenKind.Var },
	{ regex: /^volatile(?![$\w])/, tokenKind: TokenKind.Volatile },
	{ regex: /^yield(?![$\w])/, tokenKind: TokenKind.Yield },
	{ regex: /^extern(?:al)?(?![$\w])/, tokenKind: TokenKind.External },
	{ regex: /^ref(?:erence)?(?![$\w])/, tokenKind: TokenKind.Reference },
	{ regex: /^catch(?![$\w])/, tokenKind: TokenKind.Catch },
	{ regex: /^self(?![$\w])/, tokenKind: TokenKind.Self },
	{ regex: /^Self(?![$\w])/, tokenKind: TokenKind.CapitalisedSelf },
	{ regex: /^trait(?![$\w])/, tokenKind: TokenKind.Trait },
	{ regex: /^traits(?![$\w])/, tokenKind: TokenKind.Traits },
	{ regex: /^methods(?![$\w])/, tokenKind: TokenKind.Methods },
	{ regex: /^method(?![$\w])/, tokenKind: TokenKind.Method },
	{ regex: /^unsafe(?![$\w])/, tokenKind: TokenKind.Unsafe },
	{ regex: /^where(?![$\w])/, tokenKind: TokenKind.Where },
	{ regex: /^use(?![$\w])/, tokenKind: TokenKind.Use },
	{ regex: /^struct(?:ure)?(?![$\w])/, tokenKind: TokenKind.Structure },
	{ regex: /^become(?![$\w])/, tokenKind: TokenKind.Become },
	{ regex: /^box(?![$\w])/, tokenKind: TokenKind.Box },
	{ regex: /^boxed(?![$\w])/, tokenKind: TokenKind.Boxed },
	{ regex: /^macro(?![$\w])/, tokenKind: TokenKind.Macro },
	{ regex: /^override(?![$\w])/, tokenKind: TokenKind.Override },
	{ regex: /^unsized(?![$\w])/, tokenKind: TokenKind.Unsized },
	{ regex: /^sizeof(?![$\w])/, tokenKind: TokenKind.Sizeof },
	{ regex: /^size(?![$\w])/, tokenKind: TokenKind.Size },
	{ regex: /^virtual(?![$\w])/, tokenKind: TokenKind.Virtual },
	{ regex: /^union(?![$\w])/, tokenKind: TokenKind.Union },
	{ regex: /^dyn(?:amic)?(?![$\w])/, tokenKind: TokenKind.Dynamic },
	{ regex: /^async(?![$\w])/, tokenKind: TokenKind.Async },
	{ regex: /^of(?![$\w])/, tokenKind: TokenKind.Of },
	{ regex: /^def(?:ine)?(?![$\w])/, tokenKind: TokenKind.Define },
	{ regex: /^namespace(?![$\w])/, tokenKind: TokenKind.Namespace },
	{ regex: /^comptime(?![$\w])/, tokenKind: TokenKind.Comptime },
	{ regex: /^from(?![$\w])/, tokenKind: TokenKind.From },
	{ regex: /^test(?![$\w])/, tokenKind: TokenKind.Test },
	{ regex: /^tests(?![$\w])/, tokenKind: TokenKind.Tests },
	{ regex: /^unless(?![$\w])/, tokenKind: TokenKind.Unless },
	{ regex: /^any(?![$\w])/, tokenKind: TokenKind.Any },
	{ regex: /^unknown(?![$\w])/, tokenKind: TokenKind.Unknown },
	{ regex: /^unique(?![$\w])/, tokenKind: TokenKind.Unique },
	{ regex: /^symbol(?![$\w])/, tokenKind: TokenKind.Symbol },
	{ regex: /^runtime(?![$\w])/, tokenKind: TokenKind.Runtime },
	{ regex: /^opaque(?![$\w])/, tokenKind: TokenKind.Opaque },
	{ regex: /^>/, tokenKind: TokenKind.BiggerThan },
	{ regex: /^</, tokenKind: TokenKind.SmallerThan },
	{ regex: /^\./, tokenKind: TokenKind.Dot },
	{ regex: /^->/, tokenKind: TokenKind.Arrow },
	{ regex: /^=>/, tokenKind: TokenKind.ThickArrow },
	{ regex: /^:/, tokenKind: TokenKind.Colon },
	{ regex: /^\(/, tokenKind: TokenKind.OpenBracket },
	{ regex: /^\)/, tokenKind: TokenKind.CloseBracket },
	{ regex: /^\{/, tokenKind: TokenKind.OpenSquiglyBracket },
	{ regex: /^\}/, tokenKind: TokenKind.CloseSquiglyBracket },
	{ regex: /^\[/, tokenKind: TokenKind.OpenSquareBracket },
	{ regex: /^\]/, tokenKind: TokenKind.CloseSquareBracket },
	{ regex: /^,/, tokenKind: TokenKind.Comma },
	{ regex: /^\^/, tokenKind: TokenKind.Xor },
	{ regex: /^\+\+/, tokenKind: TokenKind.Increment },
	{ regex: /^--/, tokenKind: TokenKind.Decrement },
	{ regex: /^\+/, tokenKind: TokenKind.Add },
	{ regex: /^-/, tokenKind: TokenKind.Minus },
	{ regex: /^\//, tokenKind: TokenKind.Divide },
	{ regex: /^\*\*/, tokenKind: TokenKind.Power },
	{ regex: /^\*%/, tokenKind: TokenKind.WrappingTimes },
	{ regex: /^\*/, tokenKind: TokenKind.Times },
	{ regex: /^==/, tokenKind: TokenKind.Equals },
	{ regex: /^%/, tokenKind: TokenKind.Modulo },
	{ regex: /^&&/, tokenKind: TokenKind.LogicalAnd },
	{ regex: /^\|\|/, tokenKind: TokenKind.LogicalOr },
	{ regex: /^!/, tokenKind: TokenKind.LogicalNot },
	{ regex: /^&/, tokenKind: TokenKind.BitwiseAnd },
	{ regex: /^\|/, tokenKind: TokenKind.BitwiseOr },
	{ regex: /^~/, tokenKind: TokenKind.BitwiseNot },
	{ regex: /^=/, tokenKind: TokenKind.Assign },
	{ regex: /^\?\./, tokenKind: TokenKind.OptionalChain },
	{ regex: /^<</, tokenKind: TokenKind.LeftShift },
	{ regex: /^>>/, tokenKind: TokenKind.RightShift },
	{ regex: /^u([1-9]\d*)(?![$\w])/, tokenKind: TokenKind.UnsignedIntegerType },
	{ regex: /^i([1-9]\d*)(?![$\w])/, tokenKind: TokenKind.SignedIntegerType },
	{ regex: /^0b[01](?:_?[01])*/, tokenKind: TokenKind.BinaryNumber },
	{ regex: /^0x[\da-fA-F](?:_?[\da-fA-F])*/, tokenKind: TokenKind.HexNumber },
	{ regex: /^0o[0-7](?:_?[0-7])*/, tokenKind: TokenKind.OctalNumber },
	{ regex: /^\d(?:_?\d)*(?:\.\d(?:_?\d)*)?/, tokenKind: TokenKind.Number },
	{ regex: /^"(\\"|[^"]+)"/, tokenKind: TokenKind.String },
	{ regex: /^'(\\'|[^']+)'/, tokenKind: TokenKind.String },
	{ regex: /^([a-zA-Z_$][$\w]*) *\(/, tokenKind: TokenKind.Call },
	{ regex: /^([a-zA-Z_$][$\w]*)/, tokenKind: TokenKind.Identifier }
]

export const tokenise = function* (code: string): Generator<Token, void> {
	let index = 0
	let line = 1
	let column = 1
	let match

	const createToken = (kind: TokenKind, data?: string): Token => {
		const token: Token = { kind, data, index, line, column }

		// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
		if (DEBUG)
			console.log(`DEBUG tokenise()`, printToken(token))

		return token
	}

	while (index < code.length) {
		if ((match = /^((?:(?:\/\/.*)?\r?\n)+)(\t*)/.exec(code.slice(index)))) {
			yield createToken(TokenKind.Newline, match[2])
			line += match[1]!.split(``).filter(character => character == `\n`).length
			column = (match[2]!.length * 4) + 1
			index += match[0]!.length

			if (code[index] == ` `)
				throw new Error(`lines must not begin with whitespace`)
		} else {
			checkSpace:
			if (!(match = /^ +/.exec(code.slice(index)))) {
				for (const { regex, tokenKind } of tokenRegexes) {
					if ((match = regex.exec(code.slice(index)))) {
						yield createToken(tokenKind, match[1])

						break checkSpace
					}
				}

				yield createToken(TokenKind.Error, code[index])
				column++
				index++

				continue
			}

			column += match[0]!.length
			index += match[0]!.length
		}
	}

	return undefined
}

export default tokenise

export const printToken = (token: Token) => {
	if (token.data == undefined)
		return TokenKind[token.kind]

	return `${TokenKind[token.kind]} ${JSON.stringify(token.data)}`
}
